{
  Point2D.Double[] bezCurve;
  double[] u;
  double[] uPrime;
  double maxError;
  int[] splitPoint=new int[1];
  int nPts;
  double iterationError;
  int maxIterations=4;
  Point2D.Double tHatCenter=new Point2D.Double();
  int i;
  iterationError=error * error;
  nPts=last - first + 1;
  if (nPts == 2) {
    double dist=v2DistanceBetween2Points(d[last],d[first]) / 3.0;
    bezCurve=new Point2D.Double[4];
    for (i=0; i < bezCurve.length; i++) {
      bezCurve[i]=new Point2D.Double();
    }
    bezCurve[0]=d[first];
    bezCurve[3]=d[last];
    v2Add(bezCurve[0],v2Scale(tHat1,dist),bezCurve[1]);
    v2Add(bezCurve[3],v2Scale(tHat2,dist),bezCurve[2]);
    bezierPath.curveTo(bezCurve[1].x,bezCurve[1].y,bezCurve[2].x,bezCurve[2].y,bezCurve[3].x,bezCurve[3].y);
    return;
  }
  u=chordLengthParameterize(d,first,last);
  bezCurve=generateBezier(d,first,last,u,tHat1,tHat2);
  maxError=computeMaxError(d,first,last,bezCurve,u,splitPoint);
  if (maxError < error) {
    bezierPath.curveTo(bezCurve[1].x,bezCurve[1].y,bezCurve[2].x,bezCurve[2].y,bezCurve[3].x,bezCurve[3].y);
    return;
  }
  if (maxError < iterationError) {
    for (i=0; i < maxIterations; i++) {
      uPrime=reparameterize(d,first,last,u,bezCurve);
      bezCurve=generateBezier(d,first,last,uPrime,tHat1,tHat2);
      maxError=computeMaxError(d,first,last,bezCurve,uPrime,splitPoint);
      if (maxError < error) {
        bezierPath.curveTo(bezCurve[1].x,bezCurve[1].y,bezCurve[2].x,bezCurve[2].y,bezCurve[3].x,bezCurve[3].y);
        return;
      }
      u=uPrime;
    }
  }
  tHatCenter=computeCenterTangent(d,splitPoint[0]);
  fitCubic(d,first,splitPoint[0],tHat1,tHatCenter,error,bezierPath);
  v2Negate(tHatCenter);
  fitCubic(d,splitPoint[0],last,tHatCenter,tHat2,error,bezierPath);
}
