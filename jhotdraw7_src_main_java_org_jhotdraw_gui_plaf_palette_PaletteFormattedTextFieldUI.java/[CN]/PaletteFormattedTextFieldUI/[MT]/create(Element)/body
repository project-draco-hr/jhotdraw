{
  return new FieldView(elem){
    /** 
 * Adjusts the allocation given to the view
 * to be a suitable allocation for a text field.
 * If the view has been allocated more than the
 * preferred span vertically, the allocation is
 * changed to be centered vertically.  Horizontally
 * the view is adjusted according to the horizontal
 * alignment property set on the associated JTextField
 * (if that is the type of the hosting component).
 * @param a the allocation given to the view, which may need
 * to be adjusted.
 * @return the allocation that the superclass should use.
 */
    protected Shape adjustAllocationXX(    Shape a){
      if (a != null) {
        Rectangle bounds=a.getBounds();
        int vspan=(int)getPreferredSpan(Y_AXIS);
        int hspan=(int)getPreferredSpan(X_AXIS);
        if (bounds.height != vspan) {
          int slop=bounds.height - vspan;
          bounds.y+=slop / 2;
          bounds.height-=slop;
        }
        Component c=getContainer();
        if (c instanceof JTextField) {
          JTextField field=(JTextField)c;
          BoundedRangeModel vis=field.getHorizontalVisibility();
          int max=Math.max(hspan,bounds.width);
          int value=vis.getValue();
          int extent=Math.min(max,bounds.width - 1);
          if ((value + extent) > max) {
            value=max - extent;
          }
          vis.setRangeProperties(value,extent,vis.getMinimum(),max,false);
          if (hspan < bounds.width) {
            int slop=bounds.width - 1 - hspan;
            int align=((JTextField)c).getHorizontalAlignment();
            if (true) {
              if (align == LEADING) {
                align=LEFT;
              }
 else               if (align == TRAILING) {
                align=RIGHT;
              }
            }
 else {
              if (align == LEADING) {
                align=RIGHT;
              }
 else               if (align == TRAILING) {
                align=LEFT;
              }
            }
switch (align) {
case SwingConstants.CENTER:
              bounds.x+=slop / 2;
            bounds.width-=slop;
          break;
case SwingConstants.RIGHT:
        bounds.x+=slop;
      bounds.width-=slop;
    break;
}
}
 else {
bounds.width=hspan;
bounds.x-=vis.getValue();
}
}
return bounds;
}
return null;
}
@Override public void paint(Graphics gr,Shape a){
Graphics2D g=(Graphics2D)gr;
JFormattedTextField editor=(JFormattedTextField)getComponent();
if (!editor.isEditValid()) {
Rectangle r=(Rectangle)a;
g.setColor(errorIndicatorForeground);
g.setStroke(new BasicStroke(2.5f,BasicStroke.CAP_BUTT,BasicStroke.JOIN_BEVEL,0,new float[]{3f,3f},0.5f));
g.draw(new Line2D.Float(r.x,r.y + r.height - 0.5f,r.x + r.width - 1,r.y + r.height - 0.5f));
}
super.paint(g,a);
}
}
;
}
