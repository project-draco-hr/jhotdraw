{
  Point2D a, b;
  Point2D c2, c1, c0;
  a=p2.multiply(-2);
  c2=p1.add(a.add(p3));
  a=p1.multiply(-2);
  b=p2.multiply(2);
  c1=a.add(b);
  c0=new Point2D(p1.getX(),p1.getY());
  double rxrx=rx * rx;
  double ryry=ry * ry;
  final double cx2=c2.getX();
  final double cy2=c2.getY();
  final double cx1=c1.getX();
  final double cy1=c1.getY();
  final double cx0=c0.getX();
  final double cy0=c0.getY();
  final double ecx=ec.getX();
  final double ecy=ec.getY();
  double[] roots=new Polynomial(ryry * cx2 * cx2 + rxrx * cy2 * cy2,2 * (ryry * cx2 * cx1 + rxrx * cy2 * cy1),ryry * (2 * cx2 * cx0 + cx1 * cx1) + rxrx * (2 * cy2 * cy0 + cy1 * cy1) - 2 * (ryry * ecx * cx2 + rxrx * ecy * cy2),2 * (ryry * cx1 * (cx0 - ecx) + rxrx * cy1 * (cy0 - ecy)),ryry * (cx0 * cx0 + ecx * ecx) + rxrx * (cy0 * cy0 + ecy * ecy) - 2 * (ryry * ecx * cx0 + rxrx * ecy * cy0) - rxrx * ryry).getRoots();
  List<Map.Entry<Double,Point2D>> result=new ArrayList<>();
  for (int i=0; i < roots.length; i++) {
    double t=roots[i];
    if (0 <= t && t <= 1) {
      result.add(new AbstractMap.SimpleEntry<>(t,c2.multiply(t * t).add(c1.multiply(t).add(c0))));
    }
  }
  Intersection.Status status;
  if (result.size() > 0) {
    status=Intersection.Status.INTERSECTION;
  }
 else {
    return intersectPointEllipse(p1,ec,rx,ry);
  }
  return new Intersection(status,result);
}
