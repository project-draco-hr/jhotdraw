{
  Point2D a, b;
  Point2D c2, c1, c0;
  double cl;
  Point2D n;
  Point2D min=minp(a1,a2);
  Point2D max=maxp(a1,a2);
  List<Map.Entry<Double,Point2D>> result=new ArrayList<>();
  a=p2.multiply(-2);
  c2=p1.add(a.add(p3));
  a=p1.multiply(-2);
  b=p2.multiply(2);
  c1=a.add(b);
  c0=new Point2D(p1.getX(),p1.getY());
  n=new Point2D(a1.getY() - a2.getY(),a2.getX() - a1.getX());
  cl=a1.getX() * a2.getY() - a2.getX() * a1.getY();
  double[] roots=new Polynomial(n.dotProduct(c2),n.dotProduct(c1),n.dotProduct(c0) + cl).getRoots();
  Intersection.Status status=Intersection.Status.NO_INTERSECTION;
  for (int i=0; i < roots.length; i++) {
    double t=roots[i];
    if (0 <= t && t <= 1) {
      Point2D p4=lerp(p1,p2,t);
      Point2D p5=lerp(p2,p3,t);
      Point2D p6=lerp(p4,p5,t);
      if (a1.getX() == a2.getX()) {
        if (min.getY() <= p6.getY() && p6.getY() <= max.getY()) {
          status=Intersection.Status.INTERSECTION;
          result.add(new AbstractMap.SimpleEntry<>(t,p6));
        }
      }
 else       if (a1.getY() == a2.getY()) {
        if (min.getX() <= p6.getX() && p6.getX() <= max.getX()) {
          status=Intersection.Status.INTERSECTION;
          result.add(new AbstractMap.SimpleEntry<>(t,p6));
        }
      }
 else       if (gte(p6,min) && lte(p6,max)) {
        status=Intersection.Status.INTERSECTION;
        result.add(new AbstractMap.SimpleEntry<>(t,p6));
      }
    }
  }
  return new Intersection(status,result);
}
