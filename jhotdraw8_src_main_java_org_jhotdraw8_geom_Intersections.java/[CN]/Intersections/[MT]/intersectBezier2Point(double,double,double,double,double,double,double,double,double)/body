{
  final double c2x, c2y, c1x, c1y, c0x, c0y;
  c2x=x0 - 2 * x1 + x2;
  c2y=y0 - 2 * y1 + y2;
  c1x=-2 * (x0 - x1);
  c1y=-2 * (y0 - y1);
  c0x=x0;
  c0y=y0;
  final double a, b, c, d;
  a=(c2x * c2x + c2y * c2y);
  b=2 * (c1x * c2x + c1y * c2y);
  c=(c1x * c1x + c1y * c1y + 2 * c0x * c2x + 2 * c0y * c2y - 2 * c2x * cx - 2 * c2y * cy);
  d=2 * (c0x * c1x + c0y * c1y - c1x * cx - c1y * cy);
  final double[] roots=new Polynomial(4 * a,3 * b,2 * c,d).getRoots();
  final List<Map.Entry<Double,Point2D>> result=new ArrayList<>();
  final Point2D p1, p2, p3;
  p1=new Point2D(x0,y0);
  p2=new Point2D(x1,y1);
  p3=new Point2D(x2,y2);
  final double r_2=r * r;
  double bestDistance=Double.POSITIVE_INFINITY;
  for (  double t : roots) {
    final Point2D p;
    double tt;
    if (t < 0) {
      tt=0;
      p=p1;
    }
 else     if (t > 1) {
      tt=1;
      p=p3;
    }
 else {
      tt=t;
      p=p1.multiply((1 - t) * (1 - t)).add(p2.multiply(2 * (1 - t) * t)).add(p3.multiply(t * t));
    }
    double dist_2=(p.getX() - cx) * (p.getX() - cx) + (p.getY() - cy) * (p.getY() - cy);
    if (dist_2 < r_2) {
      if (dist_2 < bestDistance) {
        bestDistance=dist_2;
        result.clear();
        result.add(new AbstractMap.SimpleEntry<>(tt,p));
      }
 else       if (dist_2 == bestDistance) {
        result.add(new AbstractMap.SimpleEntry<>(tt,p));
      }
    }
  }
  return new Intersection(result);
}
