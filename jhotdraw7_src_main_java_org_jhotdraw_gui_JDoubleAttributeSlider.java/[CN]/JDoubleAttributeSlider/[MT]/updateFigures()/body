{
  if (isUpdatingSlider++ == 0) {
    double value=getValue() / scaleFactor;
    if (getView() != null && attributeKey != null) {
      if (attributeRestoreData.isEmpty()) {
        for (        Figure f : getView().getSelectedFigures()) {
          f.willChange();
          attributeRestoreData.add(f.getAttributesRestoreData());
          attributeKey.set(f,value);
          f.changed();
        }
      }
 else {
        for (        Figure f : getView().getSelectedFigures()) {
          f.willChange();
          attributeKey.set(f,value);
          f.changed();
        }
      }
    }
    if (editor != null) {
      editor.setDefaultAttribute(attributeKey,value);
    }
    if (!getModel().getValueIsAdjusting()) {
      final LinkedList<Figure> editedFigures=new LinkedList<Figure>(getView().getSelectedFigures());
      final LinkedList<Object> editUndoData=new LinkedList<Object>(attributeRestoreData);
      final double editRedoValue=value;
      UndoableEdit edit=new AbstractUndoableEdit(){
        public String getPresentationName(){
          return labels.getString(attributeKey.getKey());
        }
        public void undo() throws CannotRedoException {
          super.undo();
          Iterator<Object> di=editUndoData.iterator();
          for (          Figure f : editedFigures) {
            f.willChange();
            f.restoreAttributesTo(di.next());
            f.changed();
          }
        }
        public void redo() throws CannotRedoException {
          super.redo();
          for (          Figure f : editedFigures) {
            f.willChange();
            attributeKey.set(f,editRedoValue);
            f.changed();
          }
        }
      }
;
      getView().getDrawing().fireUndoableEditHappened(edit);
    }
  }
  isUpdatingSlider--;
}
