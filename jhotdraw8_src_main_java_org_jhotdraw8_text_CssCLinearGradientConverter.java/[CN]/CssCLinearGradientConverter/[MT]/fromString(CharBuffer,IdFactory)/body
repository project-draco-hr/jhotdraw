{
  CssTokenizer tt=new CssTokenizer(new StringReader(in.toString()));
  if (tt.nextToken() == CssTokenizer.TT_IDENT) {
    if ("none".equals(tt.currentStringValue())) {
      in.position(in.limit());
      return null;
    }
 else {
      throw new ParseException("CSS LinearGradient: \"<none>\" or \"<linear-gradient>(\"  expected",tt.getPosition());
    }
  }
  if (tt.currentToken() != CssTokenizer.TT_FUNCTION) {
    throw new ParseException("CSS LinearGradient: \"<linear-gradient>(\"  expected",tt.getPosition());
  }
  boolean isLinear=false;
  String func;
switch (tt.currentStringValue()) {
case "linear-gradient":
    isLinear=true;
  break;
default :
throw new ParseException("CSS LinearGradient: \"<linear-gradient>(\"  expected",tt.getPosition());
}
tt.skipWhitespace();
boolean needComma=false;
double startX=0.0;
double startY=0.0;
double endX=1.0;
double endY=0.0;
if (tt.nextToken() == CssTokenizer.TT_IDENT && "from".equals(tt.currentStringValue())) {
needComma=true;
}
 else {
tt.pushBack();
}
tt.skipWhitespace();
if (tt.nextToken() == CssTokenizer.TT_IDENT && "to".equals(tt.currentStringValue())) {
needComma=true;
}
 else {
tt.pushBack();
}
tt.skipWhitespace();
if (needComma) {
if (tt.nextToken() != ',') {
throw new ParseException("CSS LinearGradient: ','  expected",tt.getPosition());
}
needComma=false;
}
tt.skipWhitespace();
CycleMethod cycleMethod=CycleMethod.NO_CYCLE;
if (tt.nextToken() == CssTokenizer.TT_IDENT) {
if ("repeat".equals(tt.currentStringValue())) {
cycleMethod=CycleMethod.REPEAT;
needComma=true;
}
 else if ("reflect".equals(tt.currentStringValue())) {
cycleMethod=CycleMethod.REFLECT;
needComma=true;
}
 else {
tt.pushBack();
}
}
 else {
tt.pushBack();
}
tt.skipWhitespace();
if (tt.nextToken() != ')') {
throw new ParseException("CSS LinearGradient: ')'  expected",tt.getPosition());
}
return null;
}
