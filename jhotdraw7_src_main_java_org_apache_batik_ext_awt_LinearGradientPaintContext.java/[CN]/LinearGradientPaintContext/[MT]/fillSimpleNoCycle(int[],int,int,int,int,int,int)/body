{
  final float initConst=(dgdX * x) + gc;
  final float step=dgdX * fastGradientArraySize;
  final int fpStep=(int)(step * (1 << 16));
  final int[] grad=gradient;
  for (int i=0; i < h; i++) {
    float g=initConst + dgdY * (y + i);
    g*=fastGradientArraySize;
    g+=0.5;
    final int rowLimit=off + w;
    float check=dgdX * fastGradientArraySize * w;
    if (check < 0)     check=-check;
    if (check < .3) {
      final int val;
      if (g <= 0)       val=gradientUnderflow;
 else       if (g >= fastGradientArraySize)       val=gradientOverflow;
 else       val=grad[(int)g];
      while (off < rowLimit) {
        pixels[off++]=val;
      }
    }
 else {
      int gradSteps;
      int preGradSteps;
      final int preVal, postVal;
      if (dgdX > 0) {
        gradSteps=(int)((fastGradientArraySize - g) / step);
        preGradSteps=(int)Math.ceil(0 - g / step);
        preVal=gradientUnderflow;
        postVal=gradientOverflow;
      }
 else {
        gradSteps=(int)((0 - g) / step);
        preGradSteps=(int)Math.ceil((fastGradientArraySize - g) / step);
        preVal=gradientOverflow;
        postVal=gradientUnderflow;
      }
      if (gradSteps > w)       gradSteps=w;
      final int gradLimit=off + gradSteps;
      if (preGradSteps > 0) {
        if (preGradSteps > w)         preGradSteps=w;
        final int preGradLimit=off + preGradSteps;
        while (off < preGradLimit) {
          pixels[off++]=preVal;
        }
        g+=step * preGradSteps;
      }
      int fpG=(int)(g * (1 << 16));
      while (off < gradLimit) {
        pixels[off++]=grad[fpG >> 16];
        fpG+=fpStep;
      }
      while (off < rowLimit) {
        pixels[off++]=postVal;
      }
    }
    off+=adjust;
  }
}
