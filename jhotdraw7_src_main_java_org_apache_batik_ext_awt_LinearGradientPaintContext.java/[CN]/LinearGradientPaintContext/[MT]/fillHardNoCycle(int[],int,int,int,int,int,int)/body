{
  final float initConst=(dgdX * x) + gc;
  for (int i=0; i < h; i++) {
    float g=initConst + dgdY * (y + i);
    final int rowLimit=off + w;
    if (dgdX == 0) {
      final int val;
      if (g <= 0)       val=gradientUnderflow;
 else       if (g >= 1)       val=gradientOverflow;
 else {
        int gradIdx=0;
        while (gradIdx < gradientsLength - 1) {
          if (g < fractions[gradIdx + 1])           break;
          gradIdx++;
        }
        float delta=(g - fractions[gradIdx]);
        float idx=((delta * GRADIENT_SIZE_INDEX) / normalizedIntervals[gradIdx]) + 0.5f;
        val=gradients[gradIdx][(int)idx];
      }
      while (off < rowLimit) {
        pixels[off++]=val;
      }
    }
 else {
      int gradSteps;
      int preGradSteps;
      final int preVal, postVal;
      float gradStepsF;
      float preGradStepsF;
      if (dgdX >= 0) {
        gradStepsF=((1 - g) / dgdX);
        preGradStepsF=(float)Math.ceil((0 - g) / dgdX);
        preVal=gradientUnderflow;
        postVal=gradientOverflow;
      }
 else {
        gradStepsF=((0 - g) / dgdX);
        preGradStepsF=(float)Math.ceil((1 - g) / dgdX);
        preVal=gradientOverflow;
        postVal=gradientUnderflow;
      }
      if (gradStepsF > w)       gradSteps=w;
 else       gradSteps=(int)gradStepsF;
      if (preGradStepsF > w)       preGradSteps=w;
 else       preGradSteps=(int)preGradStepsF;
      final int gradLimit=off + gradSteps;
      if (preGradSteps > 0) {
        final int preGradLimit=off + preGradSteps;
        while (off < preGradLimit) {
          pixels[off++]=preVal;
        }
        g+=dgdX * preGradSteps;
      }
      if (dgdX > 0) {
        int gradIdx=0;
        while (gradIdx < gradientsLength - 1) {
          if (g < fractions[gradIdx + 1])           break;
          gradIdx++;
        }
        while (off < gradLimit) {
          float delta=(g - fractions[gradIdx]);
          final int[] grad=gradients[gradIdx];
          double stepsD=Math.ceil((fractions[gradIdx + 1] - g) / dgdX);
          int steps;
          if (stepsD > w)           steps=w;
 else           steps=(int)stepsD;
          int subGradLimit=off + steps;
          if (subGradLimit > gradLimit)           subGradLimit=gradLimit;
          int idx=(int)(((delta * GRADIENT_SIZE_INDEX) / normalizedIntervals[gradIdx]) * (1 << 16)) + (1 << 15);
          int step=(int)(((dgdX * GRADIENT_SIZE_INDEX) / normalizedIntervals[gradIdx]) * (1 << 16));
          while (off < subGradLimit) {
            pixels[off++]=grad[idx >> 16];
            idx+=step;
          }
          g+=dgdX * stepsD;
          gradIdx++;
        }
      }
 else {
        int gradIdx=gradientsLength - 1;
        while (gradIdx > 0) {
          if (g > fractions[gradIdx])           break;
          gradIdx--;
        }
        while (off < gradLimit) {
          float delta=(g - fractions[gradIdx]);
          final int[] grad=gradients[gradIdx];
          double stepsD=Math.ceil(delta / -dgdX);
          int steps;
          if (stepsD > w)           steps=w;
 else           steps=(int)stepsD;
          int subGradLimit=off + steps;
          if (subGradLimit > gradLimit)           subGradLimit=gradLimit;
          int idx=(int)(((delta * GRADIENT_SIZE_INDEX) / normalizedIntervals[gradIdx]) * (1 << 16)) + (1 << 15);
          int step=(int)(((dgdX * GRADIENT_SIZE_INDEX) / normalizedIntervals[gradIdx]) * (1 << 16));
          while (off < subGradLimit) {
            pixels[off++]=grad[idx >> 16];
            idx+=step;
          }
          g+=dgdX * stepsD;
          gradIdx--;
        }
      }
      while (off < rowLimit) {
        pixels[off++]=postVal;
      }
    }
    off+=adjust;
  }
}
