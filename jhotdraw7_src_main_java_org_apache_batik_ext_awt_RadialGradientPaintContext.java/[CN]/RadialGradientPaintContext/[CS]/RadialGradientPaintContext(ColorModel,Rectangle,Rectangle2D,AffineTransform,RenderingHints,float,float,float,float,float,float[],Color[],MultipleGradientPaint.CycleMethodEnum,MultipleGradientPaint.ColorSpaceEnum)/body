{
  super(cm,deviceBounds,userBounds,t,hints,fractions,colors,cycleMethod,colorSpace);
  centerX=cx;
  centerY=cy;
  focusX=fx;
  focusY=fy;
  radius=r;
  this.isSimpleFocus=(focusX == centerX) && (focusY == centerY);
  this.isNonCyclic=(cycleMethod == RadialGradientPaint.NO_CYCLE);
  radiusSq=radius * radius;
  float dX=focusX - centerX;
  float dY=focusY - centerY;
  double dist=Math.sqrt((dX * dX) + (dY * dY));
  if (dist > radius * SCALEBACK) {
    double angle=Math.atan2(dY,dX);
    focusX=(float)(SCALEBACK * radius * Math.cos(angle)) + centerX;
    focusY=(float)(SCALEBACK * radius * Math.sin(angle)) + centerY;
  }
  dX=focusX - centerX;
  trivial=(float)Math.sqrt(radiusSq - (dX * dX));
  constA=a02 - centerX;
  constB=a12 - centerY;
  Object colorRend=(hints == null) ? RenderingHints.VALUE_COLOR_RENDER_QUALITY : hints.get(RenderingHints.KEY_COLOR_RENDERING);
  Object rend=(hints == null) ? RenderingHints.VALUE_RENDER_QUALITY : hints.get(RenderingHints.KEY_RENDERING);
  fillMethod=0;
  if ((rend == RenderingHints.VALUE_RENDER_QUALITY) || (colorRend == RenderingHints.VALUE_COLOR_RENDER_QUALITY)) {
    fillMethod=ANTI_ALIAS_IMPL;
  }
  if ((rend == RenderingHints.VALUE_RENDER_SPEED) || (colorRend == RenderingHints.VALUE_COLOR_RENDER_SPEED)) {
    fillMethod=DEFAULT_IMPL;
  }
  if (fillMethod == 0) {
    fillMethod=DEFAULT_IMPL;
    if (false) {
      if (hasDiscontinuity) {
        fillMethod=ANTI_ALIAS_IMPL;
      }
 else {
        fillMethod=DEFAULT_IMPL;
      }
    }
  }
  if ((fillMethod == DEFAULT_IMPL) && (isSimpleFocus && isNonCyclic && isSimpleLookup)) {
    this.calculateFixedPointSqrtLookupTable();
    fillMethod=FIXED_POINT_IMPL;
  }
}
