{
  final double constC=-(radiusSq) + (centerX * centerX) + (centerY * centerY);
  double A;
  double B;
  double C;
  double slope;
  double yintcpt;
  double solutionX;
  double solutionY;
  final float constX=(a00 * x) + (a01 * y) + a02;
  final float constY=(a10 * x) + (a11 * y) + a12;
  final float precalc2=2 * centerY;
  final float precalc3=-2 * centerX;
  float X;
  float Y;
  float g;
  float det;
  float currentToFocusSq;
  float intersectToFocusSq;
  float deltaXSq;
  float deltaYSq;
  int indexer=off;
  int i, j;
  int pixInc=w + adjust;
  for (j=0; j < h; j++) {
    X=(a01 * j) + constX;
    Y=(a11 * j) + constY;
    for (i=0; i < w; i++) {
      if (((X - focusX) > -0.000001) && ((X - focusX) < 0.000001)) {
        solutionX=focusX;
        solutionY=centerY;
        solutionY+=(Y > focusY) ? trivial : -trivial;
      }
 else {
        slope=(Y - focusY) / (X - focusX);
        yintcpt=Y - (slope * X);
        A=(slope * slope) + 1;
        B=precalc3 + (-2 * slope * (centerY - yintcpt));
        C=constC + (yintcpt * (yintcpt - precalc2));
        det=(float)Math.sqrt((B * B) - (4 * A * C));
        solutionX=-B;
        solutionX+=(X < focusX) ? -det : det;
        solutionX=solutionX / (2 * A);
        solutionY=(slope * solutionX) + yintcpt;
      }
      deltaXSq=(float)solutionX - focusX;
      deltaXSq=deltaXSq * deltaXSq;
      deltaYSq=(float)solutionY - focusY;
      deltaYSq=deltaYSq * deltaYSq;
      intersectToFocusSq=deltaXSq + deltaYSq;
      deltaXSq=X - focusX;
      deltaXSq=deltaXSq * deltaXSq;
      deltaYSq=Y - focusY;
      deltaYSq=deltaYSq * deltaYSq;
      currentToFocusSq=deltaXSq + deltaYSq;
      g=(float)Math.sqrt(currentToFocusSq / intersectToFocusSq);
      pixels[indexer + i]=indexIntoGradientsArrays(g);
      X+=a00;
      Y+=a10;
    }
    indexer+=pixInc;
  }
}
