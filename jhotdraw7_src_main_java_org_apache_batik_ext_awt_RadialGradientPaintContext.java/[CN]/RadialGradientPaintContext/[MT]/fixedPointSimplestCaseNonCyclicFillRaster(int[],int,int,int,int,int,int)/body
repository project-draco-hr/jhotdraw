{
  float iSq=0;
  final float indexFactor=fastGradientArraySize / radius;
  final float constX=(a00 * x) + (a01 * y) + constA;
  final float constY=(a10 * x) + (a11 * y) + constB;
  final float deltaX=indexFactor * a00;
  final float deltaY=indexFactor * a10;
  float dX, dY;
  final int fixedArraySizeSq=(fastGradientArraySize * fastGradientArraySize);
  float g, gDelta, gDeltaDelta, temp;
  int gIndex;
  int iSqInt;
  int end, j;
  int indexer=off;
  temp=((deltaX * deltaX) + (deltaY * deltaY));
  gDeltaDelta=((temp * 2));
  if (temp > fixedArraySizeSq) {
    final int val=gradientOverflow;
    for (j=0; j < h; j++) {
      for (end=indexer + w; indexer < end; indexer++)       pixels[indexer]=val;
      indexer+=adjust;
    }
    return;
  }
  for (j=0; j < h; j++) {
    dX=indexFactor * ((a01 * j) + constX);
    dY=indexFactor * ((a11 * j) + constY);
    g=(((dY * dY) + (dX * dX)));
    gDelta=(((((deltaY * dY) + (deltaX * dX)) * 2) + temp));
    for (end=indexer + w; indexer < end; indexer++) {
      if (g >= fixedArraySizeSq) {
        pixels[indexer]=gradientOverflow;
      }
 else {
        iSq=(g * invSqStepFloat);
        iSqInt=(int)iSq;
        iSq-=iSqInt;
        gIndex=sqrtLutFixed[iSqInt];
        gIndex+=(int)(iSq * (sqrtLutFixed[iSqInt + 1] - gIndex));
        pixels[indexer]=gradient[gIndex];
      }
      g+=gDelta;
      gDelta+=gDeltaDelta;
    }
    indexer+=adjust;
  }
}
