{
  if ((str == null || str.length() == 0) && getAllowsNullValue()) {
    return null;
  }
  final int remaining=str.remaining();
  int end=0;
{
    boolean noMoreSigns=false;
    boolean noMorePoints=false;
    boolean noMoreEs=false;
    Outer:     for (; end < remaining; end++) {
      char c=str.charAt(end);
switch (c) {
case '+':
case '-':
        if (noMoreSigns) {
          break Outer;
        }
      noMoreSigns=true;
    break;
case '.':
  if (noMorePoints) {
    break Outer;
  }
noMoreSigns=true;
noMorePoints=true;
break;
case '0':
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
case '8':
case '9':
noMoreSigns=true;
break;
case 'e':
case 'E':
if (noMoreEs) {
break Outer;
}
noMoreSigns=false;
noMorePoints=false;
noMoreEs=true;
break;
case 'I':
case 'N':
end+=3;
break Outer;
default :
break Outer;
}
}
}
String text=str.subSequence(0,end).toString();
switch (text) {
case "-INF":
str.position(str.position() + end);
return Double.NEGATIVE_INFINITY;
case "INF":
str.position(str.position() + end);
return Double.POSITIVE_INFINITY;
case "NaN":
str.position(str.position() + end);
return Double.NaN;
}
if (unit != null && end + unit.length() <= remaining) {
if (str.subSequence(end,end + unit.length()).toString().startsWith(unit)) {
end+=unit.length();
}
}
if (text.isEmpty()) {
throw new ParseException("invalid value",str.position());
}
Object value;
double v=Double.parseDouble(text);
if (factor != 1.0) {
v=(v / factor);
}
value=new Double(v);
try {
if (!isValidValue(value,true)) {
throw new ParseException("invalid value",str.position());
}
}
 catch (ClassCastException cce) {
ParseException pe=new ParseException("invalid value",str.position());
pe.initCause(cce);
throw pe;
}
str.position(str.position() + end);
return (Double)value;
}
