{
  isSimpleLookup=false;
  int rgb1;
  int rgb2;
  int aveA=0x008000;
  int aveR=0x008000;
  int aveG=0x008000;
  int aveB=0x008000;
  for (int i=0; i < gradients.length; i++) {
    if (normalizedIntervals[i] == 0)     continue;
    gradients[i]=new int[GRADIENT_SIZE];
    rgb1=loColors[i].getRGB();
    rgb2=hiColors[i].getRGB();
    interpolate(rgb1,rgb2,gradients[i]);
    int argb=gradients[i][GRADIENT_SIZE / 2];
    float norm=normalizedIntervals[i];
    aveA+=(int)(((argb >> 8) & 0xFF0000) * norm);
    aveR+=(int)(((argb) & 0xFF0000) * norm);
    aveG+=(int)(((argb << 8) & 0xFF0000) * norm);
    aveB+=(int)(((argb << 16) & 0xFF0000) * norm);
    transparencyTest&=rgb1;
    transparencyTest&=rgb2;
  }
  gradientAverage=(((aveA & 0xFF0000) << 8) | ((aveR & 0xFF0000)) | ((aveG & 0xFF0000) >> 8)| ((aveB & 0xFF0000) >> 16));
  if (colorSpace == LinearGradientPaint.LINEAR_RGB) {
    if (dataModel.getColorSpace() == ColorSpace.getInstance(ColorSpace.CS_sRGB)) {
      for (int j=0; j < gradients.length; j++) {
        for (int i=0; i < gradients[j].length; i++) {
          gradients[j][i]=convertEntireColorLinearRGBtoSRGB(gradients[j][i]);
        }
      }
      gradientAverage=convertEntireColorLinearRGBtoSRGB(gradientAverage);
    }
  }
 else {
    if (dataModel.getColorSpace() == ColorSpace.getInstance(ColorSpace.CS_LINEAR_RGB)) {
      for (int j=0; j < gradients.length; j++) {
        for (int i=0; i < gradients[j].length; i++) {
          gradients[j][i]=convertEntireColorSRGBtoLinearRGB(gradients[j][i]);
        }
      }
      gradientAverage=convertEntireColorSRGBtoLinearRGB(gradientAverage);
    }
  }
}
