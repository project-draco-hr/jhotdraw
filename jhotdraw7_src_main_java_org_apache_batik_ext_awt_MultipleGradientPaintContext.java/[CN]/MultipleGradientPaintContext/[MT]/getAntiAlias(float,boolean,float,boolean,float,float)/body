{
  int ach=0, rch=0, gch=0, bch=0;
  if (isSimpleLookup) {
    p1*=fastGradientArraySize;
    p2*=fastGradientArraySize;
    int idx1=(int)p1;
    int idx2=(int)p2;
    int i, pix;
    if (p1_up && !p2_up && (idx1 <= idx2)) {
      if (idx1 == idx2)       return gradient[idx1];
      for (i=idx1 + 1; i < idx2; i++) {
        pix=gradient[i];
        ach+=((pix >>> 20) & 0xFF0);
        rch+=((pix >>> 12) & 0xFF0);
        gch+=((pix >>> 4) & 0xFF0);
        bch+=((pix << 4) & 0xFF0);
      }
    }
 else {
      if (p1_up) {
        for (i=idx1 + 1; i < fastGradientArraySize; i++) {
          pix=gradient[i];
          ach+=((pix >>> 20) & 0xFF0);
          rch+=((pix >>> 12) & 0xFF0);
          gch+=((pix >>> 4) & 0xFF0);
          bch+=((pix << 4) & 0xFF0);
        }
      }
 else {
        for (i=0; i < idx1; i++) {
          pix=gradient[i];
          ach+=((pix >>> 20) & 0xFF0);
          rch+=((pix >>> 12) & 0xFF0);
          gch+=((pix >>> 4) & 0xFF0);
          bch+=((pix << 4) & 0xFF0);
        }
      }
      if (p2_up) {
        for (i=idx2 + 1; i < fastGradientArraySize; i++) {
          pix=gradient[i];
          ach+=((pix >>> 20) & 0xFF0);
          rch+=((pix >>> 12) & 0xFF0);
          gch+=((pix >>> 4) & 0xFF0);
          bch+=((pix << 4) & 0xFF0);
        }
      }
 else {
        for (i=0; i < idx2; i++) {
          pix=gradient[i];
          ach+=((pix >>> 20) & 0xFF0);
          rch+=((pix >>> 12) & 0xFF0);
          gch+=((pix >>> 4) & 0xFF0);
          bch+=((pix << 4) & 0xFF0);
        }
      }
    }
    int norm, isz;
    isz=(int)((1 << 16) / (sz * fastGradientArraySize));
    ach=(ach * isz) >> 16;
    rch=(rch * isz) >> 16;
    gch=(gch * isz) >> 16;
    bch=(bch * isz) >> 16;
    if (p1_up)     norm=(int)((1 - (p1 - idx1)) * isz);
 else     norm=(int)((p1 - idx1) * isz);
    pix=gradient[idx1];
    ach+=(((pix >>> 20) & 0xFF0) * norm) >> 16;
    rch+=(((pix >>> 12) & 0xFF0) * norm) >> 16;
    gch+=(((pix >>> 4) & 0xFF0) * norm) >> 16;
    bch+=(((pix << 4) & 0xFF0) * norm) >> 16;
    if (p2_up)     norm=(int)((1 - (p2 - idx2)) * isz);
 else     norm=(int)((p2 - idx2) * isz);
    pix=gradient[idx2];
    ach+=(((pix >>> 20) & 0xFF0) * norm) >> 16;
    rch+=(((pix >>> 12) & 0xFF0) * norm) >> 16;
    gch+=(((pix >>> 4) & 0xFF0) * norm) >> 16;
    bch+=(((pix << 4) & 0xFF0) * norm) >> 16;
    ach=(ach + 0x08) >> 4;
    rch=(rch + 0x08) >> 4;
    gch=(gch + 0x08) >> 4;
    bch=(bch + 0x08) >> 4;
  }
 else {
    int idx1=0, idx2=0;
    int i1=-1, i2=-1;
    float f1=0, f2=0;
    for (int i=0; i < gradientsLength; i++) {
      if ((p1 < fractions[i + 1]) && (i1 == -1)) {
        i1=i;
        f1=p1 - fractions[i];
        f1=((f1 / normalizedIntervals[i]) * GRADIENT_SIZE_INDEX);
        idx1=(int)f1;
        if (i2 != -1)         break;
      }
      if ((p2 < fractions[i + 1]) && (i2 == -1)) {
        i2=i;
        f2=p2 - fractions[i];
        f2=((f2 / normalizedIntervals[i]) * GRADIENT_SIZE_INDEX);
        idx2=(int)f2;
        if (i1 != -1)         break;
      }
    }
    if (i1 == -1) {
      i1=gradients.length - 1;
      f1=idx1=GRADIENT_SIZE_INDEX;
    }
    if (i2 == -1) {
      i2=gradients.length - 1;
      f2=idx2=GRADIENT_SIZE_INDEX;
    }
    if (DEBUG)     System.out.println("I1: " + i1 + " Idx1: "+ idx1+ " I2: "+ i2+ " Idx2: "+ idx2);
    if ((i1 == i2) && (idx1 <= idx2) && p1_up&& !p2_up)     return gradients[i1][(idx1 + idx2 + 1) >> 1];
    int pix, norm;
    int base=(int)((1 << 16) / sz);
    if ((i1 < i2) && p1_up && !p2_up) {
      norm=(int)((base * normalizedIntervals[i1] * (GRADIENT_SIZE_INDEX - f1)) / GRADIENT_SIZE_INDEX);
      pix=gradients[i1][(idx1 + GRADIENT_SIZE) >> 1];
      ach+=(((pix >>> 20) & 0xFF0) * norm) >> 16;
      rch+=(((pix >>> 12) & 0xFF0) * norm) >> 16;
      gch+=(((pix >>> 4) & 0xFF0) * norm) >> 16;
      bch+=(((pix << 4) & 0xFF0) * norm) >> 16;
      for (int i=i1 + 1; i < i2; i++) {
        norm=(int)(base * normalizedIntervals[i]);
        pix=gradients[i][GRADIENT_SIZE >> 1];
        ach+=(((pix >>> 20) & 0xFF0) * norm) >> 16;
        rch+=(((pix >>> 12) & 0xFF0) * norm) >> 16;
        gch+=(((pix >>> 4) & 0xFF0) * norm) >> 16;
        bch+=(((pix << 4) & 0xFF0) * norm) >> 16;
      }
      norm=(int)((base * normalizedIntervals[i2] * f2) / GRADIENT_SIZE_INDEX);
      pix=gradients[i2][(idx2 + 1) >> 1];
      ach+=(((pix >>> 20) & 0xFF0) * norm) >> 16;
      rch+=(((pix >>> 12) & 0xFF0) * norm) >> 16;
      gch+=(((pix >>> 4) & 0xFF0) * norm) >> 16;
      bch+=(((pix << 4) & 0xFF0) * norm) >> 16;
    }
 else {
      if (p1_up) {
        norm=(int)((base * normalizedIntervals[i1] * (GRADIENT_SIZE_INDEX - f1)) / GRADIENT_SIZE_INDEX);
        pix=gradients[i1][(idx1 + GRADIENT_SIZE) >> 1];
      }
 else {
        norm=(int)((base * normalizedIntervals[i1] * f1) / GRADIENT_SIZE_INDEX);
        pix=gradients[i1][(idx1 + 1) >> 1];
      }
      ach+=(((pix >>> 20) & 0xFF0) * norm) >> 16;
      rch+=(((pix >>> 12) & 0xFF0) * norm) >> 16;
      gch+=(((pix >>> 4) & 0xFF0) * norm) >> 16;
      bch+=(((pix << 4) & 0xFF0) * norm) >> 16;
      if (p2_up) {
        norm=(int)((base * normalizedIntervals[i2] * (GRADIENT_SIZE_INDEX - f2)) / GRADIENT_SIZE_INDEX);
        pix=gradients[i2][(idx2 + GRADIENT_SIZE) >> 1];
      }
 else {
        norm=(int)((base * normalizedIntervals[i2] * f2) / GRADIENT_SIZE_INDEX);
        pix=gradients[i2][(idx2 + 1) >> 1];
      }
      ach+=(((pix >>> 20) & 0xFF0) * norm) >> 16;
      rch+=(((pix >>> 12) & 0xFF0) * norm) >> 16;
      gch+=(((pix >>> 4) & 0xFF0) * norm) >> 16;
      bch+=(((pix << 4) & 0xFF0) * norm) >> 16;
      if (p1_up) {
        for (int i=i1 + 1; i < gradientsLength; i++) {
          norm=(int)(base * normalizedIntervals[i]);
          pix=gradients[i][GRADIENT_SIZE >> 1];
          ach+=(((pix >>> 20) & 0xFF0) * norm) >> 16;
          rch+=(((pix >>> 12) & 0xFF0) * norm) >> 16;
          gch+=(((pix >>> 4) & 0xFF0) * norm) >> 16;
          bch+=(((pix << 4) & 0xFF0) * norm) >> 16;
        }
      }
 else {
        for (int i=0; i < i1; i++) {
          norm=(int)(base * normalizedIntervals[i]);
          pix=gradients[i][GRADIENT_SIZE >> 1];
          ach+=(((pix >>> 20) & 0xFF0) * norm) >> 16;
          rch+=(((pix >>> 12) & 0xFF0) * norm) >> 16;
          gch+=(((pix >>> 4) & 0xFF0) * norm) >> 16;
          bch+=(((pix << 4) & 0xFF0) * norm) >> 16;
        }
      }
      if (p2_up) {
        for (int i=i2 + 1; i < gradientsLength; i++) {
          norm=(int)(base * normalizedIntervals[i]);
          pix=gradients[i][GRADIENT_SIZE >> 1];
          ach+=(((pix >>> 20) & 0xFF0) * norm) >> 16;
          rch+=(((pix >>> 12) & 0xFF0) * norm) >> 16;
          gch+=(((pix >>> 4) & 0xFF0) * norm) >> 16;
          bch+=(((pix << 4) & 0xFF0) * norm) >> 16;
        }
      }
 else {
        for (int i=0; i < i2; i++) {
          norm=(int)(base * normalizedIntervals[i]);
          pix=gradients[i][GRADIENT_SIZE >> 1];
          ach+=(((pix >>> 20) & 0xFF0) * norm) >> 16;
          rch+=(((pix >>> 12) & 0xFF0) * norm) >> 16;
          gch+=(((pix >>> 4) & 0xFF0) * norm) >> 16;
          bch+=(((pix << 4) & 0xFF0) * norm) >> 16;
        }
      }
    }
    ach=(ach + 0x08) >> 4;
    rch=(rch + 0x08) >> 4;
    gch=(gch + 0x08) >> 4;
    bch=(bch + 0x08) >> 4;
    if (DEBUG)     System.out.println("Pix: [" + ach + ", "+ rch+ ", "+ gch+ ", "+ bch+ "]");
  }
  if (weight != 1) {
    int aveW=(int)((1 << 16) * (1 - weight));
    int aveA=((gradientAverage >>> 24) & 0xFF) * aveW;
    int aveR=((gradientAverage >> 16) & 0xFF) * aveW;
    int aveG=((gradientAverage >> 8) & 0xFF) * aveW;
    int aveB=((gradientAverage) & 0xFF) * aveW;
    int iw=(int)(weight * (1 << 16));
    ach=((ach * iw) + aveA) >> 16;
    rch=((rch * iw) + aveR) >> 16;
    gch=((gch * iw) + aveG) >> 16;
    bch=((bch * iw) + aveB) >> 16;
  }
  return ((ach << 24) | (rch << 16) | (gch << 8)| bch);
}
