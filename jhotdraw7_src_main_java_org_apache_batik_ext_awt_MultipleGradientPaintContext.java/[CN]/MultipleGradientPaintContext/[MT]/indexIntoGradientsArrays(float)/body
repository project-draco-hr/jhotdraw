{
  if (cycleMethod == MultipleGradientPaint.NO_CYCLE) {
    if (position >= 1) {
      return gradientOverflow;
    }
 else     if (position <= 0) {
      return gradientUnderflow;
    }
  }
 else   if (cycleMethod == MultipleGradientPaint.REPEAT) {
    position=position - (int)position;
    if (position < 0) {
      position=position + 1;
    }
    int w=0, c1=0, c2=0;
    if (isSimpleLookup) {
      position*=gradient.length;
      int idx1=(int)(position);
      if (idx1 + 1 < gradient.length)       return gradient[idx1];
      w=(int)((position - idx1) * (1 << 16));
      c1=gradient[idx1];
      c2=gradient[0];
    }
 else {
      for (int i=0; i < gradientsLength; i++) {
        if (position < fractions[i + 1]) {
          float delta=position - fractions[i];
          delta=((delta / normalizedIntervals[i]) * GRADIENT_SIZE);
          int index=(int)delta;
          if ((index + 1 < gradients[i].length) || (i + 1 < gradientsLength))           return gradients[i][index];
          w=(int)((delta - index) * (1 << 16));
          c1=gradients[i][index];
          c2=gradients[0][0];
          break;
        }
      }
    }
    return ((((((c1 >> 8) & 0xFF0000) + ((((c2 >>> 24)) - ((c1 >>> 24))) * w)) & 0xFF0000) << 8) | (((((c1) & 0xFF0000) + ((((c2 >> 16) & 0xFF) - ((c1 >> 16) & 0xFF)) * w)) & 0xFF0000)) | (((((c1 << 8) & 0xFF0000) + ((((c2 >> 8) & 0xFF) - ((c1 >> 8) & 0xFF)) * w)) & 0xFF0000) >> 8)| (((((c1 << 16) & 0xFF0000) + ((((c2) & 0xFF) - ((c1) & 0xFF)) * w)) & 0xFF0000) >> 16));
  }
 else {
    if (position < 0) {
      position=-position;
    }
    int part=(int)position;
    position=position - part;
    if ((part & 0x00000001) == 1) {
      position=1 - position;
    }
  }
  if (isSimpleLookup) {
    return gradient[(int)(position * fastGradientArraySize)];
  }
 else {
    for (int i=0; i < gradientsLength; i++) {
      if (position < fractions[i + 1]) {
        float delta=position - fractions[i];
        int index=(int)((delta / normalizedIntervals[i]) * (GRADIENT_SIZE_INDEX));
        return gradients[i][index];
      }
    }
  }
  return gradientOverflow;
}
