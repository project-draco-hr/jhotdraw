{
  if (colorSpace == LinearGradientPaint.LINEAR_RGB) {
    for (int i=0; i < loColors.length; i++) {
      loColors[i]=new Color(SRGBtoLinearRGB[loColors[i].getRed()],SRGBtoLinearRGB[loColors[i].getGreen()],SRGBtoLinearRGB[loColors[i].getBlue()],loColors[i].getAlpha());
      hiColors[i]=new Color(SRGBtoLinearRGB[hiColors[i].getRed()],SRGBtoLinearRGB[hiColors[i].getGreen()],SRGBtoLinearRGB[hiColors[i].getBlue()],hiColors[i].getAlpha());
    }
  }
  transparencyTest=0xff000000;
  if (cycleMethod == MultipleGradientPaint.NO_CYCLE) {
    transparencyTest&=gradientUnderflow;
    transparencyTest&=gradientOverflow;
  }
  gradients=new int[fractions.length - 1][];
  gradientsLength=gradients.length;
  int n=normalizedIntervals.length;
  float Imin=1;
  for (int i=0; i < n; i++) {
    Imin=(Imin > normalizedIntervals[i]) ? normalizedIntervals[i] : Imin;
  }
  int estimatedSize=0;
  if (Imin == 0) {
    estimatedSize=Integer.MAX_VALUE;
    hasDiscontinuity=true;
  }
 else {
    for (int i=0; i < normalizedIntervals.length; i++) {
      estimatedSize+=(normalizedIntervals[i] / Imin) * GRADIENT_SIZE;
    }
  }
  if (estimatedSize > MAX_GRADIENT_ARRAY_SIZE) {
    calculateMultipleArrayGradient(loColors,hiColors);
    if ((cycleMethod == MultipleGradientPaint.REPEAT) && (gradients[0][0] != gradients[gradients.length - 1][GRADIENT_SIZE_INDEX]))     hasDiscontinuity=true;
  }
 else {
    calculateSingleArrayGradient(loColors,hiColors,Imin);
    if ((cycleMethod == MultipleGradientPaint.REPEAT) && (gradient[0] != gradient[fastGradientArraySize]))     hasDiscontinuity=true;
  }
  if ((transparencyTest >>> 24) == 0xff) {
    if (dataModel.getColorSpace() == lrgbmodel_NA.getColorSpace())     dataModel=lrgbmodel_NA;
 else     if (dataModel.getColorSpace() == srgbmodel_NA.getColorSpace())     dataModel=srgbmodel_NA;
    model=dataModel;
  }
}
