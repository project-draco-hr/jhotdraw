{
  CagOperation op=getStyled(CAG_OPERATION);
  List<PathIterator> iterators=new ArrayList<>();
  Area area=null;
  boolean first=true;
  try {
    for (    Figure child : getChildren()) {
      if (child instanceof PathIterableFigure) {
        final PathIterableFigure pathIterable=(PathIterableFigure)child;
        AffineTransform childTx=tx;
        final Transform localToParent=child.getLocalToParent();
        if (localToParent != null) {
          AffineTransform ltpTx=Transforms.toAWT(localToParent);
          if (tx != null) {
            childTx=(AffineTransform)tx.clone();
            childTx.concatenate(ltpTx);
          }
 else {
            childTx=ltpTx;
          }
        }
        final PathIterator pathIterator=pathIterable.getPathIterator(childTx);
        if (first) {
          first=false;
switch (op) {
case NONE:
            iterators.add(pathIterator);
          break;
case ADD:
case INTERSECT:
case SUBTRACT:
case XOR:
        area=new Area(Shapes.buildFromPathIterator(new Path2DDoubleBuilder(),pathIterator).get());
      break;
default :
    throw new UnsupportedOperationException("" + op);
}
iterators.add(pathIterator);
}
 else {
switch (op) {
case ADD:
  area.add(new Area(Shapes.buildFromPathIterator(new Path2DDoubleBuilder(),pathIterator).get()));
break;
case NONE:
iterators.add(pathIterator);
break;
case INTERSECT:
area.intersect(new Area(Shapes.buildFromPathIterator(new Path2DDoubleBuilder(),pathIterator).get()));
break;
case SUBTRACT:
area.subtract(new Area(Shapes.buildFromPathIterator(new Path2DDoubleBuilder(),pathIterator).get()));
break;
case XOR:
area.exclusiveOr(new Area(Shapes.buildFromPathIterator(new Path2DDoubleBuilder(),pathIterator).get()));
break;
}
}
}
}
}
 catch (IOException e) {
e.printStackTrace();
}
PathIterator iter=area != null ? area.getPathIterator(null) : new CombinedPathIterator(getStyled(FILL_RULE),iterators);
double combineStrokeWidth=getStyled(COMBINE_STROKE_WIDTH);
if (combineStrokeWidth > 0) {
int cap;
int join;
switch (getStyled(COMBINE_STROKE_LINE_CAP)) {
case BUTT:
default :
cap=BasicStroke.CAP_BUTT;
break;
case ROUND:
cap=BasicStroke.CAP_ROUND;
break;
case SQUARE:
cap=BasicStroke.CAP_SQUARE;
break;
}
switch (getStyled(COMBINE_STROKE_LINE_JOIN)) {
default :
case BEVEL:
join=BasicStroke.JOIN_BEVEL;
break;
case MITER:
join=BasicStroke.JOIN_MITER;
break;
case ROUND:
join=BasicStroke.JOIN_ROUND;
break;
}
BasicStroke stroke=new BasicStroke((float)combineStrokeWidth,cap,join,getStyled(COMBINE_STROKE_MITER_LIMIT).floatValue());
Path2DDoubleBuilder builder=new Path2DDoubleBuilder();
try {
Shapes.buildFromPathIterator(builder,iter);
}
 catch (IOException ex) {
throw new InternalError(ex);
}
iter=stroke.createStrokedShape(builder.get()).getPathIterator(null);
}
return iter;
}
