{
  List<PathIterator> iterators=new ArrayList<>();
  for (  Figure child : getChildren()) {
    if (child instanceof PathIterableFigure) {
      final PathIterableFigure pathIterable=(PathIterableFigure)child;
      AffineTransform childTx=tx;
      final Transform localToParent=child.getLocalToParent();
      if (localToParent != null) {
        AffineTransform ltpTx=Transforms.toAWT(localToParent);
        if (tx != null) {
          childTx=(AffineTransform)tx.clone();
          childTx.concatenate(ltpTx);
        }
 else {
          childTx=ltpTx;
        }
      }
      iterators.add(pathIterable.getPathIterator(childTx));
    }
  }
  PathIterator iter=new CombinedPathIterator(getStyled(FILL_RULE),iterators);
  double combineStrokeWidth=getStyled(COMBINE_STROKE_WIDTH);
  if (combineStrokeWidth > 0) {
    int cap;
    int join;
switch (getStyled(COMBINE_STROKE_LINE_CAP)) {
case BUTT:
default :
      cap=BasicStroke.CAP_BUTT;
    break;
case ROUND:
  cap=BasicStroke.CAP_ROUND;
break;
case SQUARE:
cap=BasicStroke.CAP_SQUARE;
break;
}
switch (getStyled(COMBINE_STROKE_LINE_JOIN)) {
default :
case BEVEL:
join=BasicStroke.JOIN_BEVEL;
break;
case MITER:
join=BasicStroke.JOIN_MITER;
break;
case ROUND:
join=BasicStroke.JOIN_ROUND;
break;
}
BasicStroke stroke=new BasicStroke((float)combineStrokeWidth,cap,join,getStyled(COMBINE_STROKE_MITER_LIMIT).floatValue());
Path2DDoubleBuilder builder=new Path2DDoubleBuilder();
try {
Shapes.buildFromPathIterator(builder,iter);
}
 catch (IOException ex) {
throw new InternalError(ex);
}
iter=stroke.createStrokedShape(builder.get()).getPathIterator(null);
}
return iter;
}
