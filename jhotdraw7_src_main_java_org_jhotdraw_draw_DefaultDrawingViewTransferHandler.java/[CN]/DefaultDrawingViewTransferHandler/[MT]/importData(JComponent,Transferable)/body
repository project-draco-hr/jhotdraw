{
  if (DEBUG) {
    System.out.println(this + ".importData");
  }
  boolean retValue;
  if (comp instanceof DrawingView) {
    DrawingView view=(DrawingView)comp;
    final Drawing drawing=view.getDrawing();
    if (drawing.getInputFormats() == null || drawing.getInputFormats().size() == 0) {
      if (DEBUG) {
        System.out.println(this + ".importData failed - drawing has no import formats");
      }
      retValue=false;
    }
 else {
      retValue=false;
      try {
        SearchLoop:         for (        InputFormat format : drawing.getInputFormats()) {
          for (          DataFlavor flavor : t.getTransferDataFlavors()) {
            if (DEBUG) {
              System.out.println(this + ".importData trying to match " + format+ " to flavor "+ flavor);
            }
            if (format.isDataFlavorSupported(flavor)) {
              if (DEBUG) {
                System.out.println(this + ".importData importing flavor " + flavor);
              }
              LinkedList<Figure> existingFigures=new LinkedList<Figure>(drawing.getChildren());
              format.read(t,drawing,false);
              final LinkedList<Figure> importedFigures=new LinkedList<Figure>(drawing.getChildren());
              importedFigures.removeAll(existingFigures);
              view.clearSelection();
              view.addToSelection(importedFigures);
              drawing.fireUndoableEditHappened(new AbstractUndoableEdit(){
                public String getPresentationName(){
                  ResourceBundleUtil labels=ResourceBundleUtil.getLAFBundle("org.jhotdraw.draw.Labels");
                  return labels.getString("editPaste");
                }
                public void undo() throws CannotUndoException {
                  super.undo();
                  drawing.removeAll(importedFigures);
                }
                public void redo() throws CannotRedoException {
                  super.redo();
                  drawing.addAll(importedFigures);
                }
              }
);
              retValue=true;
              break SearchLoop;
            }
          }
        }
        if (retValue == false && t.isDataFlavorSupported(DataFlavor.javaFileListFlavor)) {
          java.util.List<File> files=(java.util.List<File>)t.getTransferData(DataFlavor.javaFileListFlavor);
          retValue=true;
          LinkedList<Figure> existingFigures=new LinkedList<Figure>(drawing.getChildren());
          for (          File file : files) {
            FileFormatLoop:             for (            InputFormat format : drawing.getInputFormats()) {
              if (file.isFile() && format.getFileFilter().accept(file)) {
                if (DEBUG) {
                  System.out.println(this + ".importData importing file " + file);
                }
                format.read(file,drawing,false);
              }
            }
          }
          final LinkedList<Figure> importedFigures=new LinkedList<Figure>(drawing.getChildren());
          importedFigures.removeAll(existingFigures);
          importedFigures.removeAll(existingFigures);
          if (importedFigures.size() > 0) {
            view.clearSelection();
            view.addToSelection(importedFigures);
            drawing.fireUndoableEditHappened(new AbstractUndoableEdit(){
              public String getPresentationName(){
                ResourceBundleUtil labels=ResourceBundleUtil.getLAFBundle("org.jhotdraw.draw.Labels");
                return labels.getString("editPaste");
              }
              public void undo() throws CannotUndoException {
                super.undo();
                drawing.removeAll(importedFigures);
              }
              public void redo() throws CannotRedoException {
                super.redo();
                drawing.addAll(importedFigures);
              }
            }
);
          }
        }
      }
 catch (      Throwable e) {
        if (DEBUG) {
          e.printStackTrace();
        }
      }
    }
  }
 else {
    retValue=super.importData(comp,t);
  }
  return retValue;
}
